## Introduction ##

This is a PEG implementation in JavaScript, which produces pure JavaScript packrat parsers from a PEG description of a grammar.

There is an API for compiling a parser from a grammar, and some helpful convenience functions for dealing with the parse trees that a parser produces.

## The PEG Language ##

Grammars are given to the parser generator as a parser expression grammar or PEG.

The arithmetic grammar from the demo makes a good example of the basic features.

    Expr ← Add
    
    Add ← Mult ( S? "+" S? Mult )*
    
    Mult ← Num ( S? "*" S? Num )*
    
    Num ← "0" / [1-9] [0-9]*
    
    S ← [ U+0020 ]+

PEGs are similar to context-free grammars (CFGs), but have a more imperative nature: while a CFG describes a language, which may or may not be easy to parse, and may be ambiguous, a PEG describes a deterministic parser.
The unambiguous nature of PEGs makes them an excellent choice for parsing programming languages.
Wikipedia's [article on PEGs][wp] is a good introduction.

[wp]: http://en.wikipedia.org/wiki/Parsing_expression_grammar

TODO: complete documentation of accepted PEG formalism
Until this is properly documented, see the [self-describing PEG grammar][PEG.peg].

[PEG.peg]: PEG.peg

## Compiling ##

The following API is used to produce a parser from a PEG.
To use it, include the file [PEG_generator.js][lib].
The generated parsers are pure JavaScript and have no dependencies, the library is only required to generate a parser.
This API is demonstrated in the [arithmetic parser demo][demo].

[demo]: build/demo.html
[lib]: build/PEG_generator.js

### `generateParser(peg,opts)` ###

- `peg` is a string containing the grammar
- `opts` is an optional object, documented below.

Returns either a compiled parser or an error.
The return value will be an array, either [true, &lt;parser>], or [false, &lt;error>], where &lt;parser> is a string containing the parser, which can be passed to eval() or written out to a file for later use, and &lt;error> is a string describing the error that prevented a parser from being generated.
Currently the returned errors are not very informative.
The most common reason for failure is that the provided PEG contained a syntax error.

### `generateParserThrowing(peg,opts)` ###

 Exactly the same as `generateParser(peg,opts)` except that instead of returning an array, it either returns a parser or throws an exception.

### `opts` ###

 The `opts` argument is optional and if provided, all the properties are optional.
 The defined properties are:

<!-- not yet supported in v6 codegen
- drop

  A list of parse rule names to drop from the generated parse tree.
  Any node generated by such a parse, and all its children, will not appear in the parse tree.
  This does not change what inputs will be accepted by the parser, only the parse tree that is returned.
  This is commonly used when parsing programming languages to exclude low-level or atomic rules such as whitespace, comments, individual tokens, or any other rule which is not interesting.
  By default, the full parse tree is returned, which is often convenient when designing and testing a grammar.
-->

- fname

  The returned parser will be a function.
  This option sets the name of that function.
  By default, the start token of the grammar is used as the function name.

- start

  The start rule may be given as an argument.
  By default the first parse rule in the PEG grammar is taken to be the start rule.
  Note that this can be used to create a parser for a subset of a larger grammar, which can be useful while testing.
  Only the named rule given, and its dependencies, will be included in the generated parser.

- debug

  This causes the parser generator to dump large amounts of debugging information as it generates the parser, mostly of interest to those who are working on the parser generator itself.
  It does not change the generated parser, but causes the code generator to generate additional output.

- trace

  If true, the generated parser will generate trace messages, which can be used for extremely detailed debugging of generated parsers.
  The trace output will typically be orders of magnitude larger than the parse tree, so this option should be used with care; tracing parsers work best on small inputs.
  When combined with a subset parser using `start` above, this can be a powerful debugging tool.

- asserts

  If true, the generated parser will include assertion statements, and will be considerably slower.
  This can be used to catch bugs in the parser generator itself.


## Parsing ##

Once a parser is generated using the API above, it can be used to parse input.

This and the API above are used together in the [arithmetic parsing demo][demo].
An example with a more complex grammar is provided by the [ECMAScript 5 demo][ES5demo] which parses ECMAScript (the standardized version of JavaScript) according to the formal language grammar as given in the fifth edition language specification.

[ES5demo]: build/ES5.html

The generated parsers consist of a single function with no external dependencies.
To use them, simply copy the generated parser function into your JavaScript, and call it with the input to be parsed.

A generated parser is a function which takes a string as an argument and returns a parse tree or an error.
The return value is an array, either of the form [true, <parse tree>], or [false, <pos>, <error>].
The format of the returned parse tree is described below.
In the case of a parse error, the <pos> is the position in the input at which parsing failed, and the <error> is the entire result table generated by the packrat parser.
The raw result table is most useful when debugging a grammar itself (see [doc/result_table][rt] for the format), but when it is the input text that is incorrect, a human-friendly error message is much more useful.
There are some utility functions coming soon to help make sense of this result table and generate some useful human readable error messages, but this API is not yet exported or documented.
A convenient and partially-automated way to generate such messages is high on the TODO list.

[rt]: doc/result_table

### Parse Tree Format ###

The result tree format is designed to be efficient in terms of memory.
When parsing large inputs with a complex grammar, such as when parsing a moderately sized JavaScript library using the ES5 parser, the generated parse tree can be quite a bit larger in memory than the input string.
An API to return parse trees as a stream is planned for the next release.

Each node in the parse tree is represented as an array with three elements.
The first element is the index of the parse rule that matched to create this node.
If the node is anonymous, this will be -1.
These indices can be looked up in the original grammar and correspond to the position in the grammar of each rule, for example if the start rule is the first rule given in the PEG, it will have index 0.
The second element is the length of the input that was matched by this node.
To determine the position of a node it is necessary to accumulating the matched lengths while descending into the parse tree.
The third and final element of each parse tree node is an array of child nodes.

The following example shows a short JavaScript program, the raw parse tree returned by the ES5 parser, and a pretty-printed representation of that tree (generated by the showTree function described below).
The first node in this tree, beginning "[0, 23, [..." is the match of the entire text against the Program rule.

    function f(){return 42}

    [0, 23, [[2, 23, [[-1, 8], [124, 1, []], [132, 1, [[133, 1, []]]], [-1, 3], [1, 9, [[6, 9, [[22, 9, [[-1, 6], [125, 1, []], [33, 2, [[35, 2, [[38, 2, [[40, 2, [[42, 2, [[44, 2, [[46, 2, [[48, 2, [[50, 2, [[53, 2, [[57, 2, [[59, 2, [[61, 2, [[63, 2, [[64, 2, [[65, 2, [[69, 2, [[70, 2, [[71, 2, [[80, 2, [[83, 2, [[84, 2, [[85, 2, [[-1, 1], [86, 1, []]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]], [126, 0, []]]]]]]]]]]]

    Program 0-23
     FunctionDeclaration 0-23
      anonymous 0-8
      S 8-9
      Identifier 9-10
       IdentifierName 9-10
      anonymous 10-13
      FunctionBody 13-22
       Statement 13-22
        ReturnStatement 13-22
         anonymous 13-19
         SnoLB 19-20
         Expr 20-22
          AssignmentExpr 20-22
           ConditionalExpr 20-22
            LogicalOrExpr 20-22
             LogicalAndExpr 20-22
              BitwiseOrExpr 20-22
               BitwiseXOrExpr 20-22
                BitwiseAndExpr 20-22
                 EqualityExpr 20-22
                  RelationalExpr 20-22
                   ShiftExpr 20-22
                    AdditiveExpr 20-22
                     MultiplicativeExpr 20-22
                      UnaryExpr 20-22
                       PostfixExpr 20-22
                        LeftHandSideExpr 20-22
                         NewExpr 20-22
                          MemberExpr 20-22
                           PrimaryExpr 20-22
                            Literal 20-22
                             NumericLiteral 20-22
                              DecimalLiteral 20-22
                               DecimalIntegerLiteral 20-22
                                anonymous 20-21
                                DecimalDigit 21-22
         EOS 22-22

## Parse Tree functions ##

Only two functions are exported currently for dealing with the output of a generated parser, these are `showTree` and `rawFailDump`.

### `showTree(tree, names, string)` ###

`showTree` takes three arguments: a parse tree, a rule name array, and (optionally) the parsed input string, and returns a pretty-printed ASCII representation of the parse tree like the one shown above.
The name array is used to correlate the parse rule indices with rule names, and it is provided in generated parsers as a `names` property of the parser function.
If the input string is provided, the tree will also indicate the part of the input that matched the corresponding rule.
Otherwise, only the input positions are shown, as in the tree above.

### `rawFailDump` ###

Currently there is little in the way of error reporting when a parse fails.
This is a fairly helpful function, but it tends to generate a lot of output, which requires a bit of expertise to interpret.
However, if you are debugging a parser and cannot otherwise tell why it is failing, this is probably worth trying.
The output shows each rule that was tried at each position, and whether it succeeded or failed.