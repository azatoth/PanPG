# PanPG API

## Introduction ##

PanPG is a parser generator which reads a PEG description of a grammar and writes a packrat parser in pure JavaScript.

There is an API for compiling a parser from a grammar, and some helpful convenience functions for dealing with the parse trees that a parser produces.

## The PEG Language ##

Grammars are given as a parser expression grammar (PEG).

The arithmetic grammar from the demo makes a good example of the basic features.

    Expr ← Add
     
    Add ← Mult ( S? "+" S? Mult )*
    
    Mult ← Num ( S? "*" S? Num )*
    
    Num ← "0" / [1-9] [0-9]*
    
    S ← [ U+0020 ]+

PEGs are similar to context-free grammars (CFGs), but have a more imperative nature: while a CFG describes a language, which may or may not be easy to parse, and may be ambiguous, a PEG describes a deterministic parser.
The unambiguous nature of PEGs makes them convenient for parsing programming languages.
Wikipedia's [article on PEGs][wp] is a good introduction.
PEGs do not require a separate lexer; the same formalism is used to define the grammar down to the level of individual characters.

Due to the difference in emphasis between CFGs and PEGs, what in a CFG is called a production is called a "rule" or "parse rule" here.

[wp]: http://en.wikipedia.org/wiki/Parsing_expression_grammar

TODO: complete documentation of accepted PEG formalism

Until this is properly documented, the [self-describing PEG grammar][PEG.peg] is the definitive reference.
The [ES5]

[PEG.peg]: grammars/PEG.peg

## Compiling ##

The following API is used to produce a parser from a PEG.
To use it, include the file [PanPG_generator.js][lib].
The library is only required to generate a parser, but once generated the parsers do not have any dependencies.
In most cases, rather than compiling the parser at the point of use, which is slow and requires the parser generator, the parser will instead be compiled once and then included where it will be used.
The parser generator API is demonstrated in the [arithmetic parser demo][demo].

[lib]: build/PanPG_generator.js
[demo]: build/demo.html

### `generateParser(peg,opts)` ###

- `peg` is a string, containing the grammar
- `opts`, documented below, controls various details of code generation.

The return value is an array, consisting of a Boolean indicating success followed by either the compiled parser or an error message.
When successful, the return value is [true, &lt;parser>], where &lt;parser> is a string containing a JavaScript program which declares a single function which is the parser.
This string can be passed to `eval()` or written to a file for later use.
In the case of failure, the return value is [false, &lt;error>], where &lt;error> is a string describing the error which prevented a parser from being generated.
Currently the returned errors are not very informative.
The most common reason for failure is that the provided PEG contained a syntax error.

### `generateParserThrowing(peg,opts)` ###

Exactly the same as `generateParser` above except that instead of returning an array, it either just returns a string containing the parser or throws an exception in caes where `generateParser` would have returned an error.

### `opts` ###

The `opts` argument is optional and if provided, all the properties are optional.
The defined properties and default behaviors are as follows, with the most common and most useful listed first:

<!-- not yet supported in v6 codegen
- drop

  A list of parse rule names to drop from the generated parse tree.
  Any node generated by such a parse, and all its children, will not appear in the parse tree.
  This does not change what inputs will be accepted by the parser, only the parse tree that is returned.
  This is commonly used when parsing programming languages to exclude low-level or atomic rules such as whitespace, comments, individual tokens, or any other rule which is not interesting.
  By default, the full parse tree is returned, which is often convenient when designing and testing a grammar.

- elide

  ...

-->

- fname

  The parser is returned as a JavaScript program which declares a single function.
  This option sets the name of that function.
  If the `commonjs` option is set, this sets the name of the module returned.
  By default, the start token of the grammar is used as the function name.

- start

  The start rule may be given as an argument.
  This can be used to create a parser for a subset of a grammar, which can be useful when testing or when reusing a part of a grammar.
  Only the named rule given, and its dependencies, will be included in the generated parser.
  For example, if you had a parser for C and wanted to generate a parser for just C expressions (but not statements or programs) you could do something like `generateParser(complete_C_grammar, {start:'Expression'}`.
  This can also be combined with `opts.patches` to create hybrid grammars.
  It is also possible to store different grammars (such as different versions of the same language) in the same file with different start rules, and common rules shared.
  By default, the first parse rule in the PEG grammar is taken to be the start rule.

- commonjs

  Instead of a bare function, the returned parser will be a CommonJS-compatible module.
  The name of the module will be taken from the `fname` option or the start rule if that is unset.
  The module exports a `parse` function.
  The module will be browser-compatible, so it can be used in the browser as well as in a CommonJS environment.
  This means that a hypothetical parser for language Foo could be used as `Foo.parse(...)` either in the browser, by including `&lt;script src="foo.js">&lt;/script>`, or in a CommonJS environment by using `var Foo=require('foo')`.
  By default, CommonJS output is not used and the returned program declares a single function at the top level.

- patches

  A set of patches may be provided as an array of PEGs given as strings, just like the main grammar.
  First each is parsed, then each is applied, in the order given, to the main grammar.
  To apply a patch here means that each rule appearing in it is added to the main grammar, replacing the existing rule with the same name if any.
  Since patches can override rules as well as add them, it is possible to replace or modify as much of the grammar as desired.

- trace

  If true, the generated parser will generate trace messages, which can be used for extremely detailed debugging and analysis of generated parsers.
  The trace output will typically be orders of magnitude larger than the parse tree, so this option should be turned on with care; tracing parsers work best on small inputs.
  When combined with a subset parser using `start`, this can be a powerful debugging tool.
  This is used (automatically) by the `explain` function documented below.

- debug

  This causes the parser generator to dump large amounts of debugging information as a source code comment before the parser itself.
  This data will be mostly of interest to those who are working on the parser generator itself.
  Apart from the added comment, the generated parser code is unchanged.
  By default, no debugging comment is produced.

- asserts

  If true, the generated parser will include assertion statements, and will be considerably slower.
  By design, the assertions should never fail, regardless of the grammar and input, so this is not useful for debugging grammars, only the parser generator itself.
  By default, assertions are not included in the generated parser.

### `explain(grammar,opts,input)` ###

When a particular grammar and input do not give the parse tree (or error!) that was expected, `explain` can be used to determine what the parser did in excruciating detail.
The arguments are the original PEG grammar, the options as they would be used with `generateParser`, and the sample input.
The output is a human readable string describing what the parser did at every step, in several sections.
ASCII-art is used so the string should be displayed in a monospace font with whitespace preserved.

The grammar is required because this function recompiles the parser with tracing enabled, and then runs it over the input and analyzes the trace so generated.
The generated grammar is cached by the `explain` function itself, so if called again with the same grammar and different input, it will not generate the parser again.
Nonetheless, this function can be quite slow and generates truly voluminous output, so care is advised and very small inputs are recommended.
The `start` option can be used to specify a particular parse rule to isolate issues to the relevant part of the grammar.

## Parsing ##

Once a parser is generated using the API above, it can be used to parse input.

This and the API above are used together in the [arithmetic parsing demo][demo].
An example with a more complex grammar is provided by the [ECMAScript 5 demo][ES5demo] which parses ECMAScript (the standardized version of JavaScript) according to the formal language grammar as given in the fifth edition language specification.

[ES5demo]: build/ES5.html

The generated parsers consist of a single function, or if the CommonJS output is used, a module which exports a single function.
To use the generated parser, make this function available to your other code, and call it with the input to be parsed.

A generated parser returns either a parse tree or an error.
The return value is an array, either of the form [true, &lt;parse tree>], or [false, &lt;pos>, &lt;error>, &lt;input>].
The format of these arrays may change in future versions, but the first element will always be a Boolean indicating success.
The format of the parse tree is described below.
In the case of a parse error, the &lt;pos> is the position in the input at which parsing failed.

### Parse Tree Format ###

Rather than embedded code which is executed on parser rules, the generated parser simply returns a parse tree which can be processed further as desired.
Most users will not deal with the parse trees directly but will prefer the treeWalker function, documented below.

The parse tree format is designed to use little memory (since these are parse trees not ASTs) and to allow streaming.
Streaming parsing is not yet supported but is in the works, see the [project roadmap][] for more on this.

[project roadmap]: http://inimino.org/~inimino/blog/peg_roadmap

For complete details on the parse tree format see the [documentation][].

[documentation]: doc/parse_tree_representation

## Handling Parse Trees ##

All these functions are contained in [PanPG_util.js][].
The `showTree` function displays a parse tree in ASCII-art form, while `showError` displays an error, with the offending line and column highlighted.
Rather than using `showTree` or `showError` directly, it is often more convenient to call `showResult`, which takes the output of a parser, which may be either an error or a parse tree, and calls either `showTree` or `showError` as appropriate.

[PanPG_util.js]: build/PanPG_util.js

### `showTree(tree, opts)` ###

- `tree` is a result from a successful call to a parser.

- `opts` is an object which may have the following properties:

  - `hide` is an array of rule names to be hidden in the output.

`showTree` takes a parse result and returns a pretty-printed ASCII representation of the parse tree.

The following example shows a short JavaScript program, and the parse tree that the ECMAScript 5 parser generates when parsing this program.
This tree contains parse nodes that are not interesting for most uses, so passing {hide:['anonymous','IdentifierStart','UnicodeLetter',...]} as the second argument would give a more concise output.

    function f(){return 42}

    Program 0-25 "function f(x){re…"
     FunctionDeclaration 0-25 "function f(x){re…"
      FunctionTok 0-8 "function"
      S 8-9 " "
       WhiteSpace 8-9 " "
      Identifier 9-10 "f"
       IdentifierName 9-10 "f"
        IdentifierStart 9-10 "f"
         UnicodeLetter 9-10 "f"
      anonymous 10-11 "("
      FormalParameterList 11-12 "x"
       Identifier 11-12 "x"
        IdentifierName 11-12 "x"
         IdentifierStart 11-12 "x"
          UnicodeLetter 11-12 "x"
      anonymous 12-13 ")"
      anonymous 13-14 "{"
      FunctionBody 14-24 "return x*x"
       Statement 14-24 "return x*x"
        ReturnStatement 14-24 "return x*x"
         ReturnTok 14-20 "return"
         SnoLB 20-21 " "
          WhiteSpace 20-21 " "
         Expr 21-24 "x*x"
          AssignmentExpr 21-24 "x*x"
           ConditionalExpr 21-24 "x*x"
            LogicalOrExpr 21-24 "x*x"
             LogicalAndExpr 21-24 "x*x"
              BitwiseOrExpr 21-24 "x*x"
               BitwiseXOrExpr 21-24 "x*x"
                BitwiseAndExpr 21-24 "x*x"
                 EqualityExpr 21-24 "x*x"
                  RelationalExpr 21-24 "x*x"
                   ShiftExpr 21-24 "x*x"
                    AdditiveExpr 21-24 "x*x"
                     MultiplicativeExpr 21-24 "x*x"
                      UnaryExpr 21-22 "x"
                       PostfixExpr 21-22 "x"
                        LeftHandSideExpr 21-22 "x"
                         NewExpr 21-22 "x"
                          MemberExpr 21-22 "x"
                           PrimaryExpr 21-22 "x"
                            Identifier 21-22 "x"
                             IdentifierName 21-22 "x"
                              IdentifierStart 21-22 "x"
                               UnicodeLetter 21-22 "x"
                      MultiplicativeOp 22-23 "*"
                      UnaryExpr 23-24 "x"
                       PostfixExpr 23-24 "x"
                        LeftHandSideExpr 23-24 "x"
                         NewExpr 23-24 "x"
                          MemberExpr 23-24 "x"
                           PrimaryExpr 23-24 "x"
                            Identifier 23-24 "x"
                             IdentifierName 23-24 "x"
                              IdentifierStart 23-24 "x"
                               UnicodeLetter 23-24 "x"
         EOS 24-24 ""
      anonymous 24-25 "}"

### `showError(position, message, string)` ###

`showError` takes the position at which the parse failed, the error message provided by the parser if any, and the input string.
It returns a human-readable description of the error including the line on which the failure occurred.
Note that the error will be reported at the position of the last alternative to be tried, which may be earlier in the input than the actual error, depending on the grammar.

### `showResult(result, opts)` ###

`showResult` takes the return value from a parser, and calls `showTree` or `showError` as appropriate.
It is most useful when testing and experimenting, when there are not separate code paths for a successful parse and a parse error and you just want to display the result.
The `opts` argument, if any, will be passed to `showTree`.

### `treeWalker(callbacks, result)` ###

`treeWalker` takes a set of callback functions, one per rule in the grammar, and a parse result, and walks the result parse tree, calling the callbacks provided for each node in the parse tree.

A node is visited by the walker when that node ends (post-order traversal), so the top-level rule or start rule of the grammar will be the last callback to be called by the walker.

Each callback is called with two arguments: a match object and a child array.
The match object has a text() method which returns the matched segment of the input string.
This is provided as a function rather than a string because slicing the match out of the string is a relatively expensive operation in most JavaScript engines, so generating it only for callbacks that require it speeds up execution considerably.
The match object also has `start` and `end` properties which are indices into the input string, useful for such things as syntax highlighters where the position of the parse node within the input string is important.

Five special callbacks can be provided, they are `anonymous`, which will be called back on anonymous nodes, `other` which will be called on named nodes that do not have a normal callback defined, `fail` which will be called on parse failure, `exception` which will be called (and will allow the walk to continue) in case an exception is thrown by any callback, and `warn` which will be called when potential errors are detected, such as a callback returning a value when there is no callback for the parent node to receive that value.
All of these are optional.

When a callback returns a value, it is appended to an array, and that array is provided to the callback for the parent node.
If none of a node's children's callbacks returned a value, then the second argument will be an empty array.

If a callback for the top-level node returns a value, it will be used as the return value of the `treeWalker` call itself.

There is an example use of the tree walker API in the [arithmetic demo][demo].

<!-- The HTML version can be regenerated by:

(curl -s http://boshi.inimino.org/3box/PanPG/readme_header && curl -s http://boshi.inimino.org/3box/PanPG/README | markdown) | curl -T - http://boshi.inimino.org/3box/PanPG/README.html
-->