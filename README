## Introduction ##

This is a PEG parser generator in JavaScript, which generates pure JavaScript packrat parsers from a PEG description of a grammar.

There is an API for compiling a parser from a grammar, and some helpful convenience functions for dealing with the parse trees that a parser produces.

## The PEG Language ##

Grammars are given to the parser generator as a parser expression grammar or PEG.

The arithmetic grammar from the demo makes a good example of the basic features.

    Expr ← Add
    
    Add ← Mult ( S? "+" S? Mult )*
    
    Mult ← Num ( S? "*" S? Num )*
    
    Num ← "0" / [1-9] [0-9]*
    
    S ← [ U+0020 ]+

PEGs are similar to context-free grammars (CFGs), but have a more imperative nature: while a CFG describes a language, which may or may not be easy to parse, and may be ambiguous, a PEG describes a deterministic parser.
The unambiguous nature of PEGs makes them convenient for parsing programming languages.
Wikipedia's [article on PEGs][wp] is a good introduction.

[wp]: http://en.wikipedia.org/wiki/Parsing_expression_grammar

TODO: complete documentation of accepted PEG formalism
Until this is properly documented, see the [self-describing PEG grammar][PEG.peg].

[PEG.peg]: PEG.peg

## Compiling ##

The following API is used to produce a parser from a PEG.
To use it, include the file [PEG_generator.js][lib].
The generated parsers are pure JavaScript and have no dependencies, the library is only required to generate a parser.
This API is demonstrated in the [arithmetic parser demo][demo].

[demo]: build/demo.html
[lib]: build/PEG_generator.js

### `generateParser(peg,opts)` ###

- `peg` is a string containing the grammar
- `opts` is an optional object, documented below.

Returns either a compiled parser or an error.
The return value will be an array, either [true, &lt;parser>], or [false, &lt;error>], where &lt;parser> is a string containing the parser, which can be passed to eval() or written out to a file for later use, and &lt;error> is a string describing the error that prevented a parser from being generated.
Currently the returned errors are not very informative.
The most common reason for failure is that the provided PEG contained a syntax error.

### `generateParserThrowing(peg,opts)` ###

Exactly the same as `generateParser` above except that instead it either returns a parser or throws an exception.

### `opts` ###

The `opts` argument is optional and if provided, all the properties are optional.
The defined properties are:

<!-- not yet supported in v6 codegen
- drop

  A list of parse rule names to drop from the generated parse tree.
  Any node generated by such a parse, and all its children, will not appear in the parse tree.
  This does not change what inputs will be accepted by the parser, only the parse tree that is returned.
  This is commonly used when parsing programming languages to exclude low-level or atomic rules such as whitespace, comments, individual tokens, or any other rule which is not interesting.
  By default, the full parse tree is returned, which is often convenient when designing and testing a grammar.
-->

- fname

  The returned parser will be a function.
  This option sets the name of that function.
  By default, the start token of the grammar is used as the function name.

- start

  The start rule may be given as an argument.
  By default the first parse rule in the PEG grammar is taken to be the start rule.
  Note that this can be used to create a parser for a subset of a larger grammar, which can be useful while testing.
  Only the named rule given, and its dependencies, will be included in the generated parser.

- trace

  If true, the generated parser will generate trace messages, which can be used for extremely detailed debugging of generated parsers.
  The trace output will typically be orders of magnitude larger than the parse tree, so this option should be used with care; tracing parsers work best on small inputs.
  When combined with a subset parser using `start` above, this can be a powerful debugging tool, but requires some knowledge of parser internals to interpret.

<!-- probably shouldn't be documented as these are not user-friendly
- debug

  This causes the parser generator to dump large amounts of debugging information as it generates the parser, mostly of interest to those who are working on the parser generator itself.
  It does not change the generated parser.

- asserts

  If true, the generated parser will include assertion statements, and will be considerably slower.
  This can be used to catch bugs in the parser generator itself.
-->

## Parsing ##

Once a parser is generated using the API above, it can be used to parse input.

This and the API above are used together in the [arithmetic parsing demo][demo].
An example with a more complex grammar is provided by the [ECMAScript 5 demo][ES5demo] which parses ECMAScript (the standardized version of JavaScript) according to the formal language grammar as given in the fifth edition language specification.

[ES5demo]: build/ES5.html

The generated parsers consist of a single function with no external dependencies.
To use them, simply copy the generated parser function somewhere in your project, and call it with the input to be parsed.

A generated parser is a function which takes a string as an argument and returns either a successful parse or an error.
The return value is an array, either of the form [true, &lt;parse events>], or [false, &lt;pos>, &lt;error>].
The format of the parse event array is described below.
In the case of a parse error, the <pos> is the position in the input at which parsing failed, and the <error> is a human-readable description of the error.
Currently this will be empty except in the case of UTF-16 decoding errors.
Better error reporting is high on the TODO list.

### Parse Tree Format ###

Rather than embedded code which is executed on parser rules, the generated parser simply return a parse tree which can be processed further as desired.
Since the returned result includes the entire tree, the format is designed to be efficient in terms of memory.
When parsing large inputs with a complex grammar, such as when parsing a moderately sized JavaScript library using the ES5 parser, the generated parse tree can be quite large.
Streaming parsing is in the works, see the [project roadmap] for more on this.

[project roadmap]: http://inimino.org/~inimino/blog/peg_roadmap

The parse tree is returned as an array of integers.
These can be thought of as representing "events" in the process of the parse.
There are three kinds of events: opening a node, closing a node, and emitting an anonymous node, which is self-contained.
For complete details see the parse tree [format documentation].

[format documentation]: doc/parse_tree_representation

This stream can be processed directly or can be turned into a proper tree structure with the provided `treeFromEvents` function.

The following example shows a short JavaScript program, the raw parse tree returned by the ECMAScript 5 parser, and a pretty-printed representation of that tree (generated by the showTree function described below).

    function f(){return 42}
    
    [1,3,148,-2,8,125,114,-2,1,-2,1,133,134,135,137,-2,1,-2,1,-2,1,-2,1,-1,1,5,133,134,135,137,-2,1,-2,1,-2,1,-2,1,-2,1,-1,1,-1,1,2,7,23,159,-2,6,126,114,-2,1,-2,1,34,36,39,41,43,45,47,49,51,54,58,60,62,64,65,66,70,71,72,133,134,135,137,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,63,-2,1,64,65,66,70,71,72,133,134,135,137,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,3,-2,3,-2,3,-2,3,-2,3,-2,3,-2,3,-2,3,-2,3,-2,3,-2,3,-2,3,-2,3,127,-2,0,-2,10,-2,10,-2,10,-1,1,-2,25,-2,25]


    Program 0-25 "function f(x){re…"
     FunctionDeclaration 0-25 "function f(x){re…"
      FunctionTok 0-8 "function"
      S 8-9 " "
       WhiteSpace 8-9 " "
      Identifier 9-10 "f"
       IdentifierName 9-10 "f"
        IdentifierStart 9-10 "f"
         UnicodeLetter 9-10 "f"
      anonymous 10-11 "("
      FormalParameterList 11-12 "x"
       Identifier 11-12 "x"
        IdentifierName 11-12 "x"
         IdentifierStart 11-12 "x"
          UnicodeLetter 11-12 "x"
      anonymous 12-13 ")"
      anonymous 13-14 "{"
      FunctionBody 14-24 "return x*x"
       Statement 14-24 "return x*x"
        ReturnStatement 14-24 "return x*x"
         ReturnTok 14-20 "return"
         SnoLB 20-21 " "
          WhiteSpace 20-21 " "
         Expr 21-24 "x*x"
          AssignmentExpr 21-24 "x*x"
           ConditionalExpr 21-24 "x*x"
            LogicalOrExpr 21-24 "x*x"
             LogicalAndExpr 21-24 "x*x"
              BitwiseOrExpr 21-24 "x*x"
               BitwiseXOrExpr 21-24 "x*x"
                BitwiseAndExpr 21-24 "x*x"
                 EqualityExpr 21-24 "x*x"
                  RelationalExpr 21-24 "x*x"
                   ShiftExpr 21-24 "x*x"
                    AdditiveExpr 21-24 "x*x"
                     MultiplicativeExpr 21-24 "x*x"
                      UnaryExpr 21-22 "x"
                       PostfixExpr 21-22 "x"
                        LeftHandSideExpr 21-22 "x"
                         NewExpr 21-22 "x"
                          MemberExpr 21-22 "x"
                           PrimaryExpr 21-22 "x"
                            Identifier 21-22 "x"
                             IdentifierName 21-22 "x"
                              IdentifierStart 21-22 "x"
                               UnicodeLetter 21-22 "x"
                      MultiplicativeOp 22-23 "*"
                      UnaryExpr 23-24 "x"
                       PostfixExpr 23-24 "x"
                        LeftHandSideExpr 23-24 "x"
                         NewExpr 23-24 "x"
                          MemberExpr 23-24 "x"
                           PrimaryExpr 23-24 "x"
                            Identifier 23-24 "x"
                             IdentifierName 23-24 "x"
                              IdentifierStart 23-24 "x"
                               UnicodeLetter 23-24 "x"
         EOS 24-24 ""
      anonymous 24-25 "}"

## Handling Parse Trees ##

The `treeFromEvents` function turns an event stream into a tree of nested JavaScript arrays.
The `showTree` function displays a parse tree in ASCII-art form.

### `showTree(tree, names, string)` ###

`showTree` takes three arguments: a parse tree, a rule name array, and (optionally) the parsed input string, and returns a pretty-printed ASCII representation of the parse tree like the one shown above.
The name array is used to correlate the parse rule indices with rule names, and it is provided in generated parsers as a `names` property of the parser function.
If the input string is provided, the tree will also indicate the part of the input that matched the corresponding rule.
Otherwise, only the input positions are shown, as in the tree above.