## Introduction ##

PanPG is a parser generator which reads a PEG description of a grammar and writes a packrat parser in pure JavaScript.

There is an API for compiling a parser from a grammar, and some helpful convenience functions for dealing with the parse trees that a parser produces.

## The PEG Language ##

Grammars are given as a parser expression grammar (PEG).

The arithmetic grammar from the demo makes a good example of the basic features.

    Expr ← Add
     
    Add ← Mult ( S? "+" S? Mult )*
    
    Mult ← Num ( S? "*" S? Num )*
    
    Num ← "0" / [1-9] [0-9]*
    
    S ← [ U+0020 ]+

PEGs are similar to context-free grammars (CFGs), but have a more imperative nature: while a CFG describes a language, which may or may not be easy to parse, and may be ambiguous, a PEG describes a deterministic parser.
The unambiguous nature of PEGs makes them convenient for parsing programming languages.
Wikipedia's [article on PEGs][wp] is a good introduction.

[wp]: http://en.wikipedia.org/wiki/Parsing_expression_grammar

TODO: complete documentation of accepted PEG formalism

Until this is properly documented, the [self-describing PEG grammar][PEG.peg] is probably the best reference.

[PEG.peg]: PEG.peg

## Compiling ##

The following API is used to produce a parser from a PEG.
To use it, include the file [PanPG_generator.js][lib].
The generated parsers are pure JavaScript and have no dependencies, the library is only required to generate a parser.
In most cases, rather than compiling the parser at the point of use, which is slow and requires the parser generator and its dependencies, the parser will instead be compiled once and then included where it will be used.
The parser generator API is demonstrated in the [arithmetic parser demo][demo].

[lib]: build/PanPG_generator.js
[demo]: build/demo.html

### `generateParser(peg,opts)` ###

- `peg` is a string, containing the grammar
- `opts`, documented below, controls various details of code generation.

The return value is either a compiled parser or an error.
The return value will be an array, either [true, &lt;parser>], or [false, &lt;error>], where &lt;parser> is a string containing the parser, which can be passed to eval() or written out to a file for later use, and &lt;error> is a string describing the error that prevented a parser from being generated.
Currently the returned errors are not very informative.
The most common reason for failure is that the provided PEG contained a syntax error.

### `generateParserThrowing(peg,opts)` ###

Exactly the same as `generateParser` above except that instead of returning an array, it either just returns a string containing the parser or throws an exception in caes where `generateParser` would have returned an error.

### `opts` ###

The `opts` argument is optional and if provided, all the properties are optional.
The defined properties are:

<!-- not yet supported in v6 codegen
- drop

  A list of parse rule names to drop from the generated parse tree.
  Any node generated by such a parse, and all its children, will not appear in the parse tree.
  This does not change what inputs will be accepted by the parser, only the parse tree that is returned.
  This is commonly used when parsing programming languages to exclude low-level or atomic rules such as whitespace, comments, individual tokens, or any other rule which is not interesting.
  By default, the full parse tree is returned, which is often convenient when designing and testing a grammar.

- elide

  ...

-->

- fname

  The parser is returned as a JavaScript program which declares a single function.
  This option sets the name of that function.
  By default, the start token of the grammar is used as the function name.

- commonjs

  Instead of a bare function, the returned parser will be a CommonJS-compatible module.
  The module exports a `parse` function and a `names` array.
  The module will be browser-compatible, so it can be used in the browser as well as in a CommonJS environment.
  When loaded in the browser (without an `exports` object) then `fname` option will be used as the module name.
  This means you can use the parser as `MyModuleName.parse(...)` and run the same code either in the browser by including `&lt;script src="mymodule.js">&lt;/script>`, or in a CommonJS environment by using `var MyModuleName=require('mymodule')`.

- start

  The start rule may be given as an argument.
  By default the first parse rule in the PEG grammar is taken to be the start rule.
  This can be also used to create a parser for a subset of a grammar, which can be useful when testing or when reusing a part of a grammar.
  Only the named rule given, and its dependencies, will be included in the generated parser.
  For example, if you had a parser for C and wanted to generate a parser for just C expressions (but not statements or programs) you could do something like `generateParser(complete_C_grammar, {start:'Expression'}`.
  This can also be combined with `opts.patches` to create hybrid grammars.

- patches

  A set of patches may be provided as an array of PEGs given as strings, just like the main grammar.
  First each is parsed, then each is applied, in the order given, to the main grammar.
  When a patch is applied, each rule appearing in it is added to the main grammar, replacing the existing rule with the same name if any.
  Since patches can override rules in the main grammar, it is possible to compose grammars and replace or modify as much of the grammar as desired.

- trace

  If true, the generated parser will generate trace messages, which can be used for extremely detailed debugging and analysis of generated parsers.
  The trace output will typically be orders of magnitude larger than the parse tree, so this option should be turned on with care; tracing parsers work best on small inputs.
  When combined with a subset parser using `start`, this can be a powerful debugging tool, but still requires some knowledge of parser internals to interpret.

<!-- probably shouldn't be documented as these are not user-friendly
- debug

  This causes the parser generator to dump large amounts of debugging information as it generates the parser, mostly of interest to those who are working on the parser generator itself.
  It does not change the generated parser.

- asserts

  If true, the generated parser will include assertion statements, and will be considerably slower.
  This can be used to catch bugs in the parser generator itself.
-->

## Parsing ##

Once a parser is generated using the API above, it can be used to parse input.

This and the API above are used together in the [arithmetic parsing demo][demo].
An example with a more complex grammar is provided by the [ECMAScript 5 demo][ES5demo] which parses ECMAScript (the standardized version of JavaScript) according to the formal language grammar as given in the fifth edition language specification.

[ES5demo]: build/ES5.html

The generated parsers consist of a single function with no external dependencies.
To use them, simply copy the generated parser function somewhere in your project, and call it with the input to be parsed.

A generated parser is a function which takes a string as an argument and returns either a successful parse or an error.
The return value is an array, either of the form [true, &lt;parse tree>], or [false, &lt;pos>, &lt;error>].
The format of the parse event array is described below.
In the case of a parse error, the &lt;pos> is the position in the input at which parsing failed, and the &lt;error> is a human-readable description of the error.
Currently no human-readable error is provided except in the case of UTF-16 decoding errors.
(Better error reporting should be coming in a future version, though.)

### Parse Tree Format ###

Rather than embedded code which is executed on parser rules, the generated parser simply returns a parse tree which can be processed further as desired.
When parsing large inputs with a complex grammar, such as when parsing a moderately sized JavaScript library using the ES5 parser, the generated parse tree can be quite large, so the format is designed to be efficient in terms of memory.
Streaming parsing is in the works, see the [project roadmap][] for more on this.

[project roadmap]: http://inimino.org/~inimino/blog/peg_roadmap

For complete details on the parse tree format see the [documentation][].

[documentation]: doc/parse_tree_representation

## Handling Parse Trees ##

All these functions are contained in [PanPG_util.js][].
The `showTree` function displays a parse tree in ASCII-art form, while `showError` displays an error, with the offending line and column highlighted.
Rather than using `showTree` or `showError` directly, it is often more convenient to call `showResult`, which takes the output of a parser, which may be either an error or a parse tree, and calls either `showTree` or `showError` as appropriate.

[PanPG_util.js]: build/PanPG_util.js

### `showTree(tree, opts)` ###

- `tree` is a result from a successful call to a parser.

- `opts` is an object which may have the following properties:

  - `hide` is an array of rule names to be hidden in the output.

`showTree` takes a parse result and returns a pretty-printed ASCII representation of the parse tree.

The following example shows a short JavaScript program, and the parse tree that the ECMAScript 5 parser generates when parsing this program.
This tree contains parse nodes that are not interesting for most uses, so passing {hide:['anonymous','IdentifierStart','UnicodeLetter',...]} as the second argument would give a more concise output.

    function f(){return 42}

    Program 0-25 "function f(x){re…"
     FunctionDeclaration 0-25 "function f(x){re…"
      FunctionTok 0-8 "function"
      S 8-9 " "
       WhiteSpace 8-9 " "
      Identifier 9-10 "f"
       IdentifierName 9-10 "f"
        IdentifierStart 9-10 "f"
         UnicodeLetter 9-10 "f"
      anonymous 10-11 "("
      FormalParameterList 11-12 "x"
       Identifier 11-12 "x"
        IdentifierName 11-12 "x"
         IdentifierStart 11-12 "x"
          UnicodeLetter 11-12 "x"
      anonymous 12-13 ")"
      anonymous 13-14 "{"
      FunctionBody 14-24 "return x*x"
       Statement 14-24 "return x*x"
        ReturnStatement 14-24 "return x*x"
         ReturnTok 14-20 "return"
         SnoLB 20-21 " "
          WhiteSpace 20-21 " "
         Expr 21-24 "x*x"
          AssignmentExpr 21-24 "x*x"
           ConditionalExpr 21-24 "x*x"
            LogicalOrExpr 21-24 "x*x"
             LogicalAndExpr 21-24 "x*x"
              BitwiseOrExpr 21-24 "x*x"
               BitwiseXOrExpr 21-24 "x*x"
                BitwiseAndExpr 21-24 "x*x"
                 EqualityExpr 21-24 "x*x"
                  RelationalExpr 21-24 "x*x"
                   ShiftExpr 21-24 "x*x"
                    AdditiveExpr 21-24 "x*x"
                     MultiplicativeExpr 21-24 "x*x"
                      UnaryExpr 21-22 "x"
                       PostfixExpr 21-22 "x"
                        LeftHandSideExpr 21-22 "x"
                         NewExpr 21-22 "x"
                          MemberExpr 21-22 "x"
                           PrimaryExpr 21-22 "x"
                            Identifier 21-22 "x"
                             IdentifierName 21-22 "x"
                              IdentifierStart 21-22 "x"
                               UnicodeLetter 21-22 "x"
                      MultiplicativeOp 22-23 "*"
                      UnaryExpr 23-24 "x"
                       PostfixExpr 23-24 "x"
                        LeftHandSideExpr 23-24 "x"
                         NewExpr 23-24 "x"
                          MemberExpr 23-24 "x"
                           PrimaryExpr 23-24 "x"
                            Identifier 23-24 "x"
                             IdentifierName 23-24 "x"
                              IdentifierStart 23-24 "x"
                               UnicodeLetter 23-24 "x"
         EOS 24-24 ""
      anonymous 24-25 "}"

### `showError(position, message, string)` ###

`showError` takes the position at which the parse failed, the error message provided by the parser if any (currently these are only provided on UTF-16 decoding errors), and the input string.
It returns a human-readable description of the error including the line on which the failure occurred.
Note that the error will be reported at the position of the last alternative to be tried, which may be earlier in the input than the actual error, depending on the grammar.

### `showResult(result,opts)` ###

`showResult` takes the return value from a parser, and calls `showTree` or `showError` as appropriate.
It is most useful when testing and experimenting, when there are not separate code paths for a successful parse and a parse error and you just want to display the result.
The `opts` argument, if any, will be passed on to `showTree`.

### `treeWalker(callbacks, result)` ###

`treeWalker` takes a set of callback functions, one per rule in the grammar, and a parse result, and walks the result parse tree, calling the callbacks provided for each node in the parse tree.

A node is visited by the walker when that node ends (post-order traversal), so the top-level rule or start rule of the grammar will be the last callback to be called by the walker.

Each callback is called with two arguments: a match object and a child array.
The match object has a text() method which returns the matched segment of the input string.
This is provided as a method rather than an argument directly, because slicing the input out of the string is a relatively expensive operation in most JavaScript engines, so generating it only for callbacks that require it speeds up execution considerably.
The match object also has `start` and `end` properties which are indices into the input string, useful for such things as syntax highlighters where the position of the parse node within the input string is important.

Three special callbacks can be provided, they are `any`, which will be called on every node, `anon` for anonymous nodes, and `fail` for parse failure.
The arguments to `any` and `anon` are the same, and the arguments to `fail` are the error position and failure message if any.

The callback functions can return a value.
If a callback returns a value, it will be added to an array, and that array is provided to the callback for the parent node.
If none of a node's child nodes have callbacks that return a value, then the second argument to that callback will be an empty array.

The callbacks should store or use any results they generate, as the `treeWalker` call itself does not return any data from the callbacks.
Typically the callback for the top-level rule will store a result or call a function to output its result.

The call to `treeWalker` returns an array of warnings.
When a callback returns a value when no callback was provided for the parent node, a warning will be generated.

There is an example of the tree walker API in use in the [arithmetic demo][demo].

<!-- The HTML version can be regenerated by:

(curl -s http://boshi.inimino.org/3box/PanPG/readme_header && curl -s http://boshi.inimino.org/3box/PanPG/README | markdown) | curl -T - http://boshi.inimino.org/3box/PanPG/README.html
-->