## Introduction ##

This is a PEG parser generator in JavaScript, which generates pure JavaScript packrat parsers from a PEG description of a grammar.

There is an API for compiling a parser from a grammar, and some helpful convenience functions for dealing with the parse trees that a parser produces.

## The PEG Language ##

Grammars are given to the parser generator as a parser expression grammar or PEG.

The arithmetic grammar from the demo makes a good example of the basic features.

    Expr ← Add
    
    Add ← Mult ( S? "+" S? Mult )*
    
    Mult ← Num ( S? "*" S? Num )*
    
    Num ← "0" / [1-9] [0-9]*
    
    S ← [ U+0020 ]+

PEGs are similar to context-free grammars (CFGs), but have a more imperative nature: while a CFG describes a language, which may or may not be easy to parse, and may be ambiguous, a PEG describes a deterministic parser.
The unambiguous nature of PEGs makes them convenient for parsing programming languages.
Wikipedia's [article on PEGs][wp] is a good introduction.

[wp]: http://en.wikipedia.org/wiki/Parsing_expression_grammar

TODO: complete documentation of accepted PEG formalism
Until this is properly documented, see the [self-describing PEG grammar][PEG.peg].

[PEG.peg]: PEG.peg

## Compiling ##

The following API is used to produce a parser from a PEG.
To use it, include the file [PEG_generator.js][lib].
The generated parsers are pure JavaScript and have no dependencies, the library is only required to generate a parser.
In most cases, rather than compiling the parser at the point of use, which is slow and requires the parser generator and its dependencies, the parser will instead be compiled once and then included where it will be used.
The parser generator API is demonstrated in the [arithmetic parser demo][demo].

[demo]: build/demo.html
[lib]: build/PEG_generator.js

### `generateParser(peg,opts)` ###

- `peg` is a string containing the grammar
- `opts` is an optional object, documented below.

Returns either a compiled parser or an error.
The return value will be an array, either [true, &lt;parser>], or [false, &lt;error>], where &lt;parser> is a string containing the parser, which can be passed to eval() or written out to a file for later use, and &lt;error> is a string describing the error that prevented a parser from being generated.
Currently the returned errors are not very informative.
The most common reason for failure is that the provided PEG contained a syntax error.

### `generateParserThrowing(peg,opts)` ###

Exactly the same as `generateParser` above except that instead it either returns a parser or throws an exception.

### `opts` ###

The `opts` argument is optional and if provided, all the properties are optional.
The defined properties are:

<!-- not yet supported in v6 codegen
- drop

  A list of parse rule names to drop from the generated parse tree.
  Any node generated by such a parse, and all its children, will not appear in the parse tree.
  This does not change what inputs will be accepted by the parser, only the parse tree that is returned.
  This is commonly used when parsing programming languages to exclude low-level or atomic rules such as whitespace, comments, individual tokens, or any other rule which is not interesting.
  By default, the full parse tree is returned, which is often convenient when designing and testing a grammar.
-->

- fname

  The returned parser will be a function.
  This option sets the name of that function.
  By default, the start token of the grammar is used as the function name.

- start

  The start rule may be given as an argument.
  By default the first parse rule in the PEG grammar is taken to be the start rule.
  Note that this can be used to create a parser for a subset of a larger grammar, which can be useful while testing.
  Only the named rule given, and its dependencies, will be included in the generated parser.

- trace

  If true, the generated parser will generate trace messages, which can be used for extremely detailed debugging of generated parsers.
  The trace output will typically be orders of magnitude larger than the parse tree, so this option should be used with care; tracing parsers work best on small inputs.
  When combined with a subset parser using `start` above, this can be a powerful debugging tool, but requires some knowledge of parser internals to interpret.

<!-- probably shouldn't be documented as these are not user-friendly
- debug

  This causes the parser generator to dump large amounts of debugging information as it generates the parser, mostly of interest to those who are working on the parser generator itself.
  It does not change the generated parser.

- asserts

  If true, the generated parser will include assertion statements, and will be considerably slower.
  This can be used to catch bugs in the parser generator itself.
-->

## Parsing ##

Once a parser is generated using the API above, it can be used to parse input.

This and the API above are used together in the [arithmetic parsing demo][demo].
An example with a more complex grammar is provided by the [ECMAScript 5 demo][ES5demo] which parses ECMAScript (the standardized version of JavaScript) according to the formal language grammar as given in the fifth edition language specification.

[ES5demo]: build/ES5.html

The generated parsers consist of a single function with no external dependencies.
To use them, simply copy the generated parser function somewhere in your project, and call it with the input to be parsed.

A generated parser is a function which takes a string as an argument and returns either a successful parse or an error.
The return value is an array, either of the form [true, &lt;parse events>], or [false, &lt;pos>, &lt;error>].
The format of the parse event array is described below.
In the case of a parse error, the <pos> is the position in the input at which parsing failed, and the <error> is a human-readable description of the error.
Currently this will be empty except in the case of UTF-16 decoding errors.
(Better error reporting should be coming in a future version as a side benefit of the work on commit point analysis.)

### Parse Tree Format ###

Rather than embedded code which is executed on parser rules, the generated parser simply returns a parse tree which can be processed further as desired.
When parsing large inputs with a complex grammar, such as when parsing a moderately sized JavaScript library using the ES5 parser, the generated parse tree can be quite large, so the format is designed to be efficient in terms of memory.
Streaming parsing is in the works, see the [project roadmap][] for more on this.

[project roadmap]: http://inimino.org/~inimino/blog/peg_roadmap

For complete details on the parse tree format see the [documentation][].

[documentation]: doc/parse_tree_representation

The following example shows a short JavaScript program, the raw parse tree returned by the ECMAScript 5 parser, and a pretty-printed representation of that tree (generated by the showTree function described below).

    function f(){return 42}
    
    [1,3,148,-2,8,125,114,-2,1,-2,1,133,134,135,137,-2,1,-2,1,-2,1,-2,1,-1,1,5,133
    ,134,135,137,-2,1,-2,1,-2,1,-2,1,-2,1,-1,1,-1,1,2,7,23,159,-2,6,126,114,-2,1,-2,1
    ,34,36,39,41,43,45,47,49,51,54,58,60,62,64,65,66,70,71,72,133,134,135,137,-2,1,-2
    ,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,63,-2,1,64,65,66,70,71,72,133,134,135
    ,137,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,3,-2,3,-2,3,-2,3,-2,3,-2
    ,3,-2,3,-2,3,-2,3,-2,3,-2,3,-2,3,-2,3,127,-2,0,-2,10,-2,10,-2,10,-1,1,-2,25,-2,25]

    Program 0-25 "function f(x){re…"
     FunctionDeclaration 0-25 "function f(x){re…"
      FunctionTok 0-8 "function"
      S 8-9 " "
       WhiteSpace 8-9 " "
      Identifier 9-10 "f"
       IdentifierName 9-10 "f"
        IdentifierStart 9-10 "f"
         UnicodeLetter 9-10 "f"
      anonymous 10-11 "("
      FormalParameterList 11-12 "x"
       Identifier 11-12 "x"
        IdentifierName 11-12 "x"
         IdentifierStart 11-12 "x"
          UnicodeLetter 11-12 "x"
      anonymous 12-13 ")"
      anonymous 13-14 "{"
      FunctionBody 14-24 "return x*x"
       Statement 14-24 "return x*x"
        ReturnStatement 14-24 "return x*x"
         ReturnTok 14-20 "return"
         SnoLB 20-21 " "
          WhiteSpace 20-21 " "
         Expr 21-24 "x*x"
          AssignmentExpr 21-24 "x*x"
           ConditionalExpr 21-24 "x*x"
            LogicalOrExpr 21-24 "x*x"
             LogicalAndExpr 21-24 "x*x"
              BitwiseOrExpr 21-24 "x*x"
               BitwiseXOrExpr 21-24 "x*x"
                BitwiseAndExpr 21-24 "x*x"
                 EqualityExpr 21-24 "x*x"
                  RelationalExpr 21-24 "x*x"
                   ShiftExpr 21-24 "x*x"
                    AdditiveExpr 21-24 "x*x"
                     MultiplicativeExpr 21-24 "x*x"
                      UnaryExpr 21-22 "x"
                       PostfixExpr 21-22 "x"
                        LeftHandSideExpr 21-22 "x"
                         NewExpr 21-22 "x"
                          MemberExpr 21-22 "x"
                           PrimaryExpr 21-22 "x"
                            Identifier 21-22 "x"
                             IdentifierName 21-22 "x"
                              IdentifierStart 21-22 "x"
                               UnicodeLetter 21-22 "x"
                      MultiplicativeOp 22-23 "*"
                      UnaryExpr 23-24 "x"
                       PostfixExpr 23-24 "x"
                        LeftHandSideExpr 23-24 "x"
                         NewExpr 23-24 "x"
                          MemberExpr 23-24 "x"
                           PrimaryExpr 23-24 "x"
                            Identifier 23-24 "x"
                             IdentifierName 23-24 "x"
                              IdentifierStart 23-24 "x"
                               UnicodeLetter 23-24 "x"
         EOS 24-24 ""
      anonymous 24-25 "}"

## Handling Parse Trees ##

The `showTree` function displays a parse tree in ASCII-art form, while `showError` displays an error, with the offending line and column highlighted.
Rather than using `showTree` or `showError` directly, it is often more convenient to call `showResult`, which takes the output of a parser, which may be either an error or a parse tree, and calls either `showTree` or `showError` as appropriate.

### `showTree(tree, names, string)` ###

`showTree` takes three arguments: a parse tree, a rule name array, and the parsed input string, and returns a pretty-printed ASCII representation of the parse tree like the one shown above.
The name array is used to correlate the parse rule indices with rule names, and it is provided in generated parsers as a `names` property of the parser function itself.
The second and third arguments are optional.
If the input string is provided, the tree will indicate the part of the input that matched, as in the example above.
If the names array is provided, the rule names will be used, as above; otherwise only the rule indices will appear in the tree.

### `showError(position, message, string)` ###

`showError` takes the position at which the parse failed, the error message provided by the parser if any (currently these are only provided on UTF-16 decoding errors), and the input string.
It returns a human-readable description of the error including the line on which the failure occurred.
Note that the error will be reported at the position of the last alternative to be tried, which may be earlier in the input than the actual error, depending on the grammar.

### `showResult(result, names, string)` ###

`showResult` takes the result of calling a parser with an input string.
This result will either be a parse tree or an indication of an error.
In either case, `showResult` calls the appropriate function and returns either the ASCII-art tree or the error message and the offending line in the input.

<!-- The HTML version can be regenerated by:
(curl -s http://boshi.inimino.org/3box/PEG/readme_header && curl -s http://boshi.inimino.org/3box/PEG/READMown) | curl -T - http://boshi.inimino.org/3box/PEG/README.html
-->