<!doctype html>

<title>PanPG demo</title>

<style>
body,html {margin:0;padding:0;background:#bbb}
fieldset {width:96%;border:0;padding:0 2%;margin:0;position:relative}
label {display:inline-block;width:40%;border:2px solid black;margin:1em 4.5%;position:relative;background:#AAA}
textarea {width:100%;height:24em;border:0}
h1,p,pre {width:80%;margin:1em auto}
h1 {margin-bottom:1.5em}
#status {height:8em;overflow:auto}
#choose_grammar select {float:right;display:block}
</style>

<script src=PanPG_generator.js></script>
<script src=PanPG_util.js></script>

<h1>PanPG demo 2010-04-28</h1>

<p>This is a very simple demo that demonstrates the PanPG API.
We load a PEG from a file, generate a parser, use that parser to parse some input, display the resulting parse or error, and finally walk the parse tree to generate a result.
You can edit the grammar, the arithmetic expression, and the parse tree callbacks, and your changes will take effect in real time.

<p>The parser generator also has Unicode support, including characters outside the BMP, though this demo doesn't use them.

<p>This is the new codegen, you can see <a href=http://boshi.inimino.org/3box/asof/1269629763069/PEG/build/demo.html>the previous version</a>, or read <a href=http://inimino.org/~inimino/blog/peg_roadmap>the project roadmap</a>.
There's also an <a href=ES5.html>an ECMAScript parser demo</a>.

<pre id=status></pre>

<!--
<fieldset id=choose_grammar>
<label>Choose a grammar to load:<select>
 <option>arithmetic grammar
</select></label>
</fieldset>
-->

<fieldset>
<label>Grammar: <br><textarea id=PEG spellcheck=false></textarea></label>
<label>Generated parser: <br><textarea readonly id=parser></textarea></label>
<label>Input: <br><textarea id=text spellcheck=false></textarea></label>
<label>Parse tree: <br><textarea readonly id=parse_tree></textarea></label>
<label>Callbacks: <br><textarea id=walker spellcheck=false></textarea></label>
<label>Output: <br><textarea id=output readonly></textarea></label>
</fieldset>

<script>
var inputPEG_el=document.getElementById('PEG')
  , inputText_el=document.getElementById('text')
  , inputWalker_el=document.getElementById('walker')
  , parser_el=document.getElementById('parser')
  , parseTree_el=document.getElementById('parse_tree')
  , status_el=document.getElementById('status')
  , output_el=document.getElementById('output')
  , ms
  , the_grammar
  , the_parser
  , the_input
  , the_result
  , the_walker_code
  , the_walker
  , the_output
  , sample_input='arith_test_expr'
  , sample_walker='arith_callbacks'

// report what we are doing and how long it takes:
function start(s){status_el.innerHTML+=s+'... ';ms=+new Date}
function finish(){status_el.innerHTML+=(+new Date-ms)+'ms\n';status_el.scrollTop=status_el.scrollHeight}

function xhr(method,uri,body,callback){var headers,p
 // instead of a method string, the first argument can be an object with method and headers properties
 if(typeof method==='object'){headers=method.headers;method=method.method}
 var x=new XMLHttpRequest()
 x.onreadystatechange=function(){if (x.readyState==4){callback(x)}}
 x.open(method,uri,true)
 if(headers) for(p in headers){x.setRequestHeader(p,headers[p])}
 x.send(body)}

start('fetching grammar file')
xhr('GET','../PEG_arith.peg',null,function(x){finish();updateParser(x.responseText)})

function updateParser(peg){var result,compilerOpts,parser
 the_grammar=peg
 inputPEG_el.value=the_grammar
 start('generating parser')
 compilerOpts=
 {} // see the API documentation for the available options, here we just accept the defaults
 result=generateParser(the_grammar,compilerOpts)
 finish()
 if(result[0])parser_el.value=result[1]
 else{parser_el.value='Error: '+result[1];return}
 start('loading the parser...')
 eval(parser_el.value) // here we use eval, but more commonly the generated parser will be written to a file and used more than once
 the_parser=Expr // put Expr, the generated parser, in the outer scope
 finish()
 if(inputText_el.value==''){ // if there is no input to parse, then fetch the sample file
  start('fetching the input file')
  xhr('GET',sample_input,null,function(x){
   inputText_el.value=x.responseText
   finish()
   updateParseTree()})}
 else{
  updateParseTree()}}

function updateParseTree(){
 the_input=inputText_el.value
 start('parsing')
 the_result=the_parser(the_input)
 finish()
 start('rendering the parser output')
 parseTree_el.value=showResult(the_result)
 finish()
 if(!the_walker_code){
  start('fetching the tree walker')
  xhr('GET',sample_walker,null,function(x){
   inputWalker_el.value=x.responseText
   finish()
   updateWalker()})}
 else{
  updateWalker()}}

function updateWalker(){var x
 start('eval() the callbacks')
 the_walker_code=inputWalker_el.value
 try{the_walker=eval('('+the_walker_code+')')}
 catch(e){output_el.value=e;finish();return}
 finish()
 updateWalkerOutput()}

function updateWalkerOutput(){var x,warnings
 start('walk the parse tree')
 try{warnings=treeWalker(the_walker/*actually the dict...*/,the_result)}
 catch(e){output_el.value=e;finish();return}
 if(warnings.length){output_el.value=warnings.join('\n')+'\n\n'+the_output}
 else output_el.value=the_output
 finish()}

function updateIfChanged(){if(the_input!=inputText_el.value) updateParseTree()}

function updateParserIfChanged(){if(the_grammar!=inputPEG_el.value) updateParser(inputPEG_el.value)}

function updateWalkerIfChanged(){if(the_walker_code!=inputWalker_el.value) updateWalker()}

function delay(f,ms){return function(){
 if(f.pending) clearTimeout(f.pending)
 f.pending = setTimeout(f,ms)}}

function onChange(el,f,ms){
 el.onkeydown=el.onkeyup=el.onclick=delay(f,ms)}

onChange(inputText_el,updateIfChanged,50)
onChange(inputPEG_el,updateParserIfChanged,50)
onChange(inputWalker_el,updateWalkerIfChanged,50)

inputText_el.focus()

</script>