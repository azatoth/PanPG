// (event array (can be partial), [name array], [input string], [state]) → [ascii-art tree, state]
// -or-
// (complete event array, [name array], [input string]) → ascii-art
// if the event array doesn't describe a complete, finished tree, or if the state value argument is provided, then the ascii-art and the state value will be returned as an array
// this is for examining partial tree fragments as they are generated by a streaming parser
// if the event array is complete and the state argument is not provided then only the ascii-art will be returned
function showTree(a,names,str,opts,state){var i,l,indent,name,x,out=[],output_positions=[],node,out_pos,state_was_passed
 opts=opts||{};opts.hide=opts.hide||[]
 state_was_passed=!!state
 state=state||{stack:[],indent:'',pos:0}
 for(i=0,l=a.length;i<l;i++){x=a[i]
  if(x>0){
   if(names){
    name=names[x]
    if(!name) return err('no such rule index in name array: '+x)}
   else name=''+x
   output_positions[state.stack.length]=out.length
   node={index:x,name:name,start:state.pos}
   out.push(show(state,node))
   state.indent+=' '
   state.stack.push(node)}
  else if(x==-1){
   i++
   if(i==l){i--;return}
   node={name:'anonymous',start:state.pos,end:state.pos+a[i]}
   state.pos=node.end
   out.push(show(state,node))
   }
  else if(x==-2){
   i++
   if(i==l)return err('incomplete close event, expected length at position '+i+' but found end of input array')
   y=state.stack.pop()
   state.pos=y.end=y.start+a[i]
   out_pos=output_positions[state.stack.length]
   state.indent=state.indent.slice(0,-1)
   if(out_pos!=undefined){
    out[out_pos]=show(state,y)}}
  else return err('invalid event '+x+' at position '+i)
  }
 if(state_was_passed || state.stack.length) return [out.join(''),state]
 else return out.join('')
 function err(s){return ['showTree: '+s]}
 function show(state,node){var text=''
  if(opts.hide.indexOf(node.name)>-1)return ''
  if(node.end!=undefined && str){
   text=show_str(str.slice(node.start,node.end))}
  return state.indent+node.name+' '+node.start+'-'+(node.end||'?')+' '+text+'\n'}
 function show_str(s){
  return '"'+s.replace(/\n/g,'\\n').replace(/\r/g,'\\r').replace(/(.{16}).{8,}/,"$1…")+'"'}}

// inspired by: http://gist.github.com/312863
function showError(pos,msg,str){var line_number,col,lines,line,start,end,prefix,suffix,arrow
 msg=msg||'Parse error'
 if(str==undefined)return msg+' at position '+pos
 prefix=str.slice(0,pos)
 suffix=str.slice(pos)
 line_number=prefix.split('\n').length
 start=prefix.lastIndexOf('\n')+1
 end=suffix.indexOf('\n')
 if(end==-1) end=str.length
 else end=prefix.length+end
 line=str.slice(start,end)
 line=line.replace('\t',' ')
 col=pos-start
 arrow=Array(col).join('-')+'^'
 return msg+' at line '+line_number+' column '+col+'\n'+line+'\n'+arrow}

function showResult(r,names,str){
 if(r[0])return showTree(r[1],names,str)
 return showError(r[1],r[2],str)}

function treeWalker(dict,names){var p,any,anon,fail,index,cb={},stack=[],frame,pos=0,warnings=[]
 for(p in dict) if(dict.hasOwnProperty(p)){
  if(p=='any'){any=dict[p];continue}
  if(p=='anon'){anon=dict[p];continue}
  if(p=='fail'){fail=dict[p];continue}
  index=names.indexOf(p)
  if(index==-1) err('rule not found in rule names: '+p)
  cb[index]=dict[p]}
 return function(result,str){var i,l,x,retval,events
  if(!result[0]){
   if(fail) fail(result[1],result[2])
   return}
  events=result[1]
  for(i=0,l=events.length;i<l;i++){x=events[i]
   if(x>0){ // named rule start
    stack.push(frame)
    frame={index:x,start:pos}
    if(cb[x]) frame.cn=[]}
   else if(x==-1){ // anonymous node
    i++
    if(i==l)err('incomplete anonymous node')
    if(anon)anon({start:pos,end:pos+events[i]})
    pos+=events[i]}
   else if(x==-2){ // node close
    i++
    if(i==l)err('incomplete rule close')
    pos=frame.start+events[i]
    x=frame.index
    if(cb[x])
     try{retval=cb[x](m(frame.start,pos),frame.cn)}
     catch(e){err('exception in '+names[x]+': '+e.toString())}
    frame=stack.pop() // the parent node
    if(cb[x] && retval!==undefined)
     if(frame.cn)frame.cn.push(retval)
     else warnings.push('ignored return value of '+names[x]+' in '+names[frame.index])}
   else err('invalid event stream: saw '+x+' at position '+i)}
  return warnings
  function m(s,e){
   return {start:s
          ,end:e
          ,text:function(){return str.slice(s,e)}}}}
 function err(s){
  throw new Error('streamHandler: '+s)}}
