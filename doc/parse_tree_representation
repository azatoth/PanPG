Updated: 2009-12-16

The code which the PEG parser generator generates produces a syntax tree as its output.
The data structure used to store this tree is described here.

The parse tree is returned as a root node.
Nodes are described below and may contain other nodes as children.
A node is represented as a JavaScript array of three elements: a rule index, a length, and a child node array.

The rule index is the 0-based index at which the matched rule appeared in the PEG given to the code generator.
For example if the start rule is the first rule in the PEG (as it often is) then the root node in a successful parse will have the rule index 0.
Nodes may also be anonymous, corresponding to terminals appearing with non-terminals in the same rule.
As an example, a successful parse of the rule Mult ← Num "*" Num will generate a Mult node with three child nodes.
The first and third nodes correspond to the Num rule, but the middle node matched only the literal string "*" which does not have any name in the grammar, hence this creates an anonymous node.
Rules which only match terminal symbols and do not also contain non-terminal rules do not generate anonymous nodes, e.g. if the rule above were rewritten as Mult ← Num MultOp Num; MultOp ← "*" then no anonymous node would be generated.
Anonymous nodes have -1 in place of the rule index.

The second element in each parse node is the length, which is the number of terminal symbols (e.g. characters) matched by that application of the rule.
If "2*2" is parsed by the Mult rule given above, the length of the Mult node will be 3, and the length of each Num node, and of the anonymous node matching the asterisk, will be 1.
To find the position of a node in the input string, it is necessary to accumulate the lengths of the nodes while descending into the tree.

Finally, the child node array contains the node's children in the same format.

Example:

Here is a complete grammar, sample input, and the corresponding parse tree:

Expr ← Add
Add ← Mult ( S? "+" S? Mult )*
Mult ← Num ( S? "*" S? Num )*
Num ← "0" / [1-9] [0-9]*
S ← [ U+0020 ]+

"4 * 3 + 2"

[0, 9, [[1, 9, [[2, 5, [[3, 1, []], [4, 1, []], [-1, 1], [4, 1, []], [3, 1, []]]], [4, 1, []], [-1, 1], [4, 1, []], [2, 1, [[3, 1, []]]]]]]]


Finding a tree path from an offset
----------------------------------

If we have a position p in the input, and wish to find the corresponding path into the parse tree, we apply this algorithm, beginning with the root node, a running offset of 0, and an empty result path:

- Increase the running offset by the length of this node.
- If the running offset is greater than p then this node contains the position.
  - push this node onto the result path.
  - run this algorithm on each child node until one returns true or there are no more child nodes.
  - return true.
- otherwise return false.

This means that finding a path into a parse tree is linear in the number of left-siblings of the path.
That is, for each node on the path, each of its sibling nodes to the left (previous in the input string) must be visited and one addition operation performed.
If the parse tree represents a typical program in a typical programming language, this means one would skip over any blocks, statements, function declarations, or whatever other top-level rules the grammar may have, which appear previous to the top-level rule containing the position of interest.
Average runtime to generate a path, then, can be expected to be linear in the input position, with some factor that varies with the "chunkiness" of the grammar and the input.


Replacing a subtree
-------------------

Assume we have a change to the input and wish to apply the corresponding change to the parse tree directly, without reparsing the entire input.
Assume that the change is provided as a path into the tree to a node which exists, and a new node to insert at that position, replacing the node already present.
The provided node may have a different length than the replaced node, so the rest of the tree may need to be updated to remain consistent.
The start offset of the new node is taken to be the same as that of the one being replaced.

First, we locate the old node by following the path, keeping a reference to each node on the path.
Let d be the difference between the length of the new and old node.
Set the start offset of the new node to that of the old node.
Replace the old node with the new node in the tree.
For each parent node seen along the path, add d to its length.


Building the parse tree
-----------------------

We build a parse tree from a result table which is generated by the packrat parser.
In this table we have, for each successful rule match, an end position and a set of rule indices and start positions for the child matches.
For each match in the table we produce a new array.
The first element is the rule index.
The second element is the length.
The third element is the children of this node, if any, each of which may be anonymous or named.
If the node has at least one child match, we insert anonymous child nodes, using -1 for the rule index, such that the sum of the lengths of the anonymous and named children is equal to the length of the node itself, and that the sum of the lengths of the left-siblings of any node are equal to the offset of that node's match relative to the match of its parent.
If there are no named rule matches, we do not insert an anonymous child node.
So the constraint holds that every node N is either a leaf node having no children, or has child nodes such that the sum of their lengths is equal to the length of N.
Anonymous nodes are always leaf nodes.
An anonymous node always has at least one non-anonymous sibling.
Two anonymous nodes are never adjacent siblings.


Streaming parse tree output
---------------------------

The streaming parser API allows input to be parsed in chunks.
Grammar annotations on the PEG define chunk points at which parsing is guaranteed not to backtrack, and the accumulated parse tree can be returned to the caller at these points.
Each chunk is returned as a single array of integers.

When a node is opened, the rule index is given, followed by either a length, if known, or -1, if the length is not yet known when the chunk is returned.
Leaf nodes will always include a length, and the length of a higher node can be determined by summing the lengths of the child nodes that have been seen when the node is closed.
A node may be opened in one chunk, its children returned in several separate chunks, and finally closed in another chunk.
This means that inclusion of a node's children in the array that defines the node, as in the non-streaming tree format, is not possible.
Instead each node is explicitly closed by the integer -2 appearing in the stream.

The caller can construct a tree or tree fragment from the stream, or process the stream directly.
Since the parser is streaming, it is entirely possible for the parse to fail in the middle of the input after many events have already been generated.
The only guarantee is that if the entire input parses successfully, the parse tree returned will be the correct one.


Constructing a parse tree from the streaming output
---------------------------------------------------

The main differences between the streaming output and the non-streaming output are:
- the streaming output does not use arrays for child node containment, but indicates the end of a node explicitly.
- the streaming output does not contain lengths for all nodes, since when open nodes are emitted the length is not yet known.

Both of these can be fixed up easily enough after the fact once the entire tree is known.

We provide a utility function which takes a stream of parse tree events and reconstructs a full parse tree from them at the end.

This function emits a "ready" event when it is ready for further chunks, or "tree" when it has constructed a finished tree.
If there no tree event is emitted, then the chunks provided to the function do not constitute a complete tree.
If there are events after what should be the end of the stream (i.e. more nodes after the top-level node has been closed) then the function will throw an exception.

When the function sees a tree chunk, it acts on each element in the array as follows:

Initially:
The current string position is 0.
The current array position is 0.

If a node is opened, call a helper function with the rule index and current position.
The helper function has a local array to hold the child nodes.
The helper function advances the array position.
If the next element is -1, this must be a named rule and the length will be derived from the length of its child nodes.
- If this is the case and the rule was anonymous, it is an error.
Otherwise, increment the current string position by the length of the node.
If the next element is -2:
- return a new node, as [<index>, <current string position - start position>, <children>]
Otherwise:
- call the helper function recursively with the rule index and current string position
- add the return value to the child array
- when it returns the current string position will have already been advanced