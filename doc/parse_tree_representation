The code which the PEG parser generator generates produces a syntax tree as its output.
The data structure used to store this tree is described here.

The tree is returned as a node.
A node is stored as a JavaScript array and contains four values: a rule index, a start offset, a length, and a child node array.

The rule index is the 0-based index at which the matched rule appeared in the PEG given to the code generator.

The start offset is the offset of the beginning of the match from the /end/ of the node's previous sibling, or, if it has no previous sibling, from the start of the parent node.
This field is necessary because PEG rules can contain anonymous expressions which consume input but do not contribute any child nodes to the parse tree, therefore the input matched by a parse tree node may not be fully covered by its child nodes.
(By adding anonymous matches to the parse tree, and assigning rule indices for them, we could eliminate this field.)
(An alternative is to not assign rule indices for specific anonymous expressions, but to just use a -1 rule index for all anonymous matches.)

The length is the number of characters of the input matched by the rule.

The child node array contains the node's children, in the same format, in source order.


Finding a tree path from an offset
----------------------------------

If we have a position p in the input, and wish to find the corresponding path into the tree, we apply this algorithm, beginning with the root node, a running offset of 0, and an empty result path:

- Increase the running offset by the start offset of this node.
- If the result is greater than p, return false.
- Increase the running offset by the length of this node.
- If the result is greater than p then this node contains p.
  - push this node onto the result path.
  - run this algorithm on each child node in order as long as each one returns false.
  - return true.
- otherwise return false.

This means that finding a path into a parse tree is linear in the number of left-siblings of the path.
That is, for each node on the path, each of its sibling nodes to the left (previous in the input string) must be visited and two addition operations performed.
In a typical program in a typical programming language, this means one would skip over any blocks, statements, function declarations, or whatever other top-level rules the grammar may have, which appear previous to the top-level rule containing the position of interest.
Average runtime to generate a path, then, can be expected to be linear in the input position, with some factor that varies with the "chunkiness" of the grammar and the input.


Replacing a subtree
-------------------

Assume we have a change to the input and wish to apply the corresponding change to the parse tree directly, without reparsing the entire input.
Assume that the change is provided as a path into the tree to a node which exists, and a new node to insert at that position, replacing the node already present.
The provided node may have a different length than the replaced node, so the rest of the tree may need to be updated to remain consistent.
The start offset of the new node is taken to be the same as that of the one being replaced.

First, we locate the old node by following the path, keeping a reference to each node on the path.
Let d be the difference between the length of the new and old node.
Set the start offset of the new node to that of the old node.
Replace the old node with the new node in the tree.
For each parent node seen along the path, add d to its length.


Building the parse tree
-----------------------

We build a parse tree from a result table which is generated by the packrat parser.
In this table we have, for each successful rule match, an end position and a set of rule indices and start positions for the child matches.
For each match in the table we produce a new array.
The first element is the rule index.
The second element is the length.
The third element is the children of this node, if any, each of which may be anonymous or named.
If the node has at least one child match, we insert anonymous child nodes, using -1 for the rule index, such that the sum of the lengths of the anonymous and named children is equal to the length of the node itself, and that the sum of the lengths of the previous siblings of any node are equal to the offset of that node's match relative to the match of its parent.
If there are no named rule matches, we do not insert an anonymous child node.
So the constraint holds that every node N is either a leaf node having no children, or has child nodes such that the sum of their lengths is equal to the length of N.
Anonymous nodes are always leaf nodes.
An anonymous node always has at least one non-anonymous sibling.
Two anonymous nodes are never adjacent siblings.