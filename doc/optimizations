Date: 2009-06-15

Notes on PEG optimizations.

A straightforward packrat parser records the results of every successful or unsuccessful match of each non-terminal at each character position which is tested until the entire input is parsed.

This preserves the linear space guarantee, but with a larger constant factor than in more commonly used parser styles.

By analyzing a PEG, it is hoped that memory usage can be minimized by removing results from the table, or avoiding adding them, when it can be proved that they will not be accessed again.

The PEG language under consideration includes:

 - Ordered choice: "A / B / ..."
 - Sequence: "A B ..."
 - Repetition operator: "A*"
 - Positive lookahead "&A"
 - Negative lookahead "!A"
 - Terminal symbols

Other repetition operators "A+" and "A?" may be replaced by "A A*" and "(A / ϵ)" respectively.

When parsing an input string from a start token S, we wish to produce a parse tree containing the match of the start rule and all its descendant matches.
Unsuccessful results and their successful match result descendants are undesired in the final result table (from which we generate a parse tree).

If S ← A / B, with A not occurring in the transitive closure of B, then there is never a need to cache the result of A.

If S ← A*, with non-recursive A, once an A has succeeded, every failure result in the table under the successful match can be freed.

Repetition operators, ordered choice, and lookaheads introduce backtracking contexts, in which a failing match will not terminate the parse and may produce results that will be useful to other rules that remain to be tried.

At any given point in a parse there is a stack of rules from the start rule to the currently-under-consideration rule.
Any of these rules may fail.
We can define a <dfn>backtracking alternate set</dfn> containing all the rules that may potentially be tried if the current parse branch fails.
If the branch succeeds there will be no backtracking (unless we are in a lookahead).
(For this purpose we may regard lookaheads as branches that are guaranteed to fail, as the parser will always backtrack over them.)
For each rule in the stack, consider any sibling rules to the right (as defined below) as members of the backtracking alternate set.
A rule "to the right" means a rule that could be tried after a failure of the current rule.
If the current rule is quantified with "*" then the rules following it in the sequence are "to the right".
Any rules appearing in subsequent alternatives of an ordered choice are "to the right".

What we are interested in, at the moment when a parse rule is reached, is whether or not that particular result, i.e. that (parse rule, input position, result) triple will ever be accessed again.
If the branch succeeds, the rule is not in a lookahead, and the rule consumes input, then it will not be accessed again (except as part of the returned parse tree).
If the branch fails or is a lookahead, or if the rule succeeds consuming no input, it may or may not be tested again at the same position.
