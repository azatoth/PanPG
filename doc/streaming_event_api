Date: 2010-03-30
Status: notes

The most direct API for dealing with the event stream produced by the v6 parsers is one that simply calls a handler for each event.

The caller provides a dictionary of callback functions, and as the parser proceeds, it calls the functions that are defined each time a node is opened or closed, or when an anonymous node is emitted.

This is trivial to implement, has effectively no overhead, and the approach is familiar to users of similar event-based streaming parser APIs such as SAX.

It leaves tree construction up to the user, and does not provide the rich selection facilities of TAL, but in simple cases this is adequate.

It is also nearly equivalent to the embedded code facilities of many other parser generators, and can easily be combined with the parser generator itself if desired, creating a parser with embedded code.

API:

// f_XXX :: (Dict, Names) → event stream → _

The dictionary has Rule_open(), Rule_close() (where "Rule" is the name of some rule in the grammar), anonymous(), and fail() methods, all of which are optional.

The argument to a Rule_open() call is the start position (the rule name is implied by the callback which is being called).
The arguments to a Rule_close() call are the start and end positions.
The arguments to an anonymous() call are the start and end positions.

Any desired tree building, etc, can be done by the caller.

With this we can probably remove the TAL dependency in the current codegen and this should speed it up considerably.